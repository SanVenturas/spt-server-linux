name: Linux Server Build and Docker Image

on:
  schedule:
    - cron: "0 4 * * *" # Nightly build at 4am UTC
  repository_dispatch:
    types: [build-trigger]
  workflow_dispatch:
    inputs:
      buildTag:
        description: "The tag to build on"
        required: true
        type: string

concurrency:
  group: linux-server-build
  cancel-in-progress: true

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.check-existence.outputs.proceed }}
      is_nightly: ${{ steps.determine-context.outputs.is_nightly }}
      target_tag: ${{ steps.determine-context.outputs.target_tag }}
      build_type: ${{ steps.determine-build-type.outputs.build_type }}

    steps:
      - name: Determine Build Context
        id: determine-context
        shell: bash
        env:
          EVENT_NAME: ${{ github.event_name }}
          CLIENT_PAYLOAD_TAG: ${{ github.event.client_payload.tag }}
          WORKFLOW_INPUT_TAG: ${{ github.event.inputs.buildTag }}
        run: |
          echo "Determining build context..."
          if [[ "$EVENT_NAME" == "schedule" ]]; then
            echo "is_nightly=true" >> $GITHUB_OUTPUT
            echo "Context is nightly build"
          else
            echo "is_nightly=false" >> $GITHUB_OUTPUT
            # Determine the tag based on the event type
            if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
              TAG_NAME="$WORKFLOW_INPUT_TAG"
            elif [[ "$EVENT_NAME" == "repository_dispatch" ]]; then
              TAG_NAME="$CLIENT_PAYLOAD_TAG"
            else
              echo "Unsupported event: $EVENT_NAME"
              exit 1
            fi

            if [[ -z "$TAG_NAME" ]]; then
              echo "No tag provided in event payload."
              exit 1
            fi
            echo "target_tag=$TAG_NAME" >> $GITHUB_OUTPUT
            echo "Target tag is $TAG_NAME"
          fi

      - name: Determine Build Type
        id: determine-build-type
        shell: bash
        run: |
          if [[ "${{ steps.determine-context.outputs.is_nightly }}" == "true" ]]; then
            BUILD_TYPE="nightly"
          else
            TARGET_TAG="${{ steps.determine-context.outputs.target_tag }}"
            TARGET_TAG_UPPER="${TARGET_TAG^^}"

            BUILD_TYPE="debug"
            if [[ "$TARGET_TAG_UPPER" =~ -BEM ]]; then
              BUILD_TYPE="bleedingmods"
            elif [[ "$TARGET_TAG_UPPER" =~ -BE ]]; then
              BUILD_TYPE="bleeding"
            elif [[ "$TARGET_TAG_UPPER" =~ v?[0-9]+\.[0-9]+\.[0-9]+ ]]; then
              BUILD_TYPE="release"
            fi
          fi
          echo "build_type=$BUILD_TYPE" >> $GITHUB_OUTPUT
          echo "Build type is $BUILD_TYPE"

      - name: Check Existence
        id: check-existence
        shell: bash
        run: |
          PROCEED="true"
          if [[ "${{ steps.determine-context.outputs.is_nightly }}" == "true" ]]; then
            echo "Nightly build, no tag check needed."
          else
            TAG="${{ steps.determine-context.outputs.target_tag }}"
            REPO="https://github.com/your-org/your-repo.git"
            echo "Checking for tag $TAG in $REPO..."
            if ! git ls-remote --tags $REPO $TAG | grep -q $TAG; then
              echo "Tag $TAG not found in $REPO"
              PROCEED="false"
            fi
          fi
          echo "proceed=$PROCEED" >> $GITHUB_OUTPUT
          echo "Matches found. Proceeding with build."

      - name: Tag Not Found
        if: steps.check-existence.outputs.proceed == 'false'
        run: |
          echo "Required tag not found in repository, halting workflow."
          exit 1

  build-linux-server:
    needs: prepare
    if: needs.prepare.outputs.proceed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake

      - name: Build Linux server
        run: |
          mkdir -p build
          cd build
          cmake ..
          make -j$(nproc)

      - name: Save build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-server-build
          path: build/

  build-docker-image:
    needs: build-linux-server
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: linux-server-build
          path: build/

      - name: Build Docker image for ARM64
        run: |
          docker buildx build \
            --platform linux/arm64 \
            -t ${{ secrets.DOCKER_HUB_USERNAME }}/linux-server:latest \
            -t ${{ secrets.DOCKER_HUB_USERNAME }}/linux-server:${{ github.sha }} \
            --push \
            .

  post-build:
    needs: build-docker-image
    runs-on: ubuntu-latest
    steps:
      - name: Post Build Info to Discord
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          BUILD_TYPE: ${{ needs.prepare.outputs.build_type }}
          DOCKER_IMAGE: ${{ secrets.DOCKER_HUB_USERNAME }}/linux-server:${{ github.sha }}
        shell: bash
        run: |
          TIMESTAMP=$(date --iso-8601=seconds)
          FOOTER_MESSAGES=("You look great today!" "Don't ban me, Phantom!" "Powered by coffee" "Life's too short to remove USB safely" "Did you remember to hydrate today?" "Have you tried turning it off and on again?" "There's no place like 127.0.0.1" "In Chomp we trust" "Beep boop, I'm a bot" "Keep calm and commit your code" "This isn't a bug, it's an undocumented feature." "May the source be with you" "Go to bed, Terk" "Please direct all support requests to Drakia" "Meaw" "Chomp approves of this message" "Chomp is life, Chomp is love" "Drakia denies all involvement" "Drakia left this note here just to confuse you" "Katalyst is the reason we can’t have nice things" "Katalyst voted against this message" "Powered by caffeine, chaos, and Chomp" "RaiRai says hi-hi" "RaiRai wants to remind you that sarcasm is a skill" "Refringe just wobbled" "Refringe might be watching--Or coding--Probably both" "Refringe rewrote this embed thirty times" "Refringe, professional button-pusher extraordinaire" "Sarix would like you to reconsider your choices" "Stella is currently judging your grammar" "Stella just gave this embed a 6/10" "Waffle has entered the chat, and now it’s weird" "Waffle is too busy stacking layers of chaos" "Waffle would like to speak to the manager of logic")
          FOOTER_MESSAGE="${FOOTER_MESSAGES[$RANDOM % ${#FOOTER_MESSAGES[@]}]}"

          EMBED_COLOR=5763719
          EMBED_DESCRIPTION="A new Docker image has been built and pushed to Docker Hub."

          fields_json='[
            {"name": "Build Type", "value": "'"$BUILD_TYPE"'", "inline": true},
            {"name": "Docker Image", "value": "'"$DOCKER_IMAGE"'", "inline": true}
          ]'

          payload=$(jq -n \
            --argjson fields "$fields_json" \
            --arg EMBED_DESCRIPTION "$EMBED_DESCRIPTION" \
            --argjson EMBED_COLOR "$EMBED_COLOR" \
            --arg FOOTER_MESSAGE "$FOOTER_MESSAGE" \
            --arg TIMESTAMP "$TIMESTAMP" \
            '{
              "content": $EMBED_DESCRIPTION,
              "embeds": [
                {
                  "title": "Build Information",
                  "color": $EMBED_COLOR,
                  "fields": $fields,
                  "footer": {"text": $FOOTER_MESSAGE, "icon_url": "https://i.imgur.com/28JJJec.png"},
                  "timestamp": $TIMESTAMP
                }
              ],
              "username": "BuildBot",
              "avatar_url": "https://i.imgur.com/28JJJec.png"
            }')
          echo "$payload" > payload_discord.json

          echo "Payload Generated:"
          cat payload_discord.json

          echo "Sending Payload..."
          curl -H "Content-Type: application/json" \
            -X POST \
            --data-binary @payload_discord.json \
            $DISCORD_WEBHOOK_URL
